#!/usr/bin/env python3
import json
import time
from datetime import datetime, timedelta, timezone
from functools import reduce
from json import JSONDecodeError
from threading import Timer

import requests
import yaml

from measure import Measure

DESC = 'NewRelic measure driver for Optune'
HAS_CANCEL = True
VERSION = '0.0.1'

DFLT_WARMUP = 0
DFLT_DURATION = 120

NEWRELIC_API_KEY = str(open('/run/secrets/optune_newrelic_api_key').read()).strip()
API_URL = 'https://api.newrelic.com/v2'
INSTANCE_METRICS_URL = '/applications/{app_id}/instances/{instance_id}/metrics/data.json'
INSTANCES_URL = '/applications/{app_id}/instances.json'

with open('./config.yaml') as f:
    config = yaml.load(f.read())['newrelic']

session = requests.Session()
session.headers.update({'X-Api-Key': NEWRELIC_API_KEY})


def newrelic_request(path, params, retries=3, method='get', **kwargs):
    retry = retries
    last_error = None
    while retry:
        try:
            res = getattr(session, method)(url=API_URL + path, params=params, **kwargs)
            return res.json()
        except Exception as e:
            last_error = e
            retry -= 1
            continue
        except JSONDecodeError as e:
            raise Exception('Expected JSON as a response from "{}" but got something else. '
                            'Error: {}'.format(path, str(e)))
    if last_error:
        raise last_error
    raise Exception('We ran out of retries (total {}) for NewRelic request to '
                    '"{} {}" with params "{}"'.format(retries, method.upper(), path, json.dumps(params)))


class Metrics:
    def __init__(self, metrics):
        self.metrics = {m['name']: m for m in metrics}

    def get_metric_values_timeseries(self, metric_name):
        # Convert from:
        # [{a: 1}, {a: 2}, {a: 3}]
        # To:
        # {a: [1, 2, 3]}
        def fn(memo, timeslice):
            ret = {**memo}
            for name, value in timeslice['values'].items():
                # Set empty array for the value we have not seen before.
                ret.setdefault(name, []).append(value)
            return ret
        assert metric_name in self.metrics, 'Requested metric with name "{}" is not found. ' \
                                            'Available metrics are ' \
                                            '"{}"'.format(metric_name, '", "'.join(self.metrics.keys()))
        # Convert from
        # [{values: {a: 1, b: 2, ...}}, ...]
        # To
        # {a: [1, 2, ...], ...}
        return reduce(fn, self.metrics[metric_name]['timeslices'], {})


class APMException(Exception):
    pass


class APM:
    def __init__(self, app_id, instance_hostname_query):
        self.app_id = app_id
        self.hostname_query = instance_hostname_query

    def get_instance_ids_by_query(self, query):
        data = newrelic_request(INSTANCES_URL.format(app_id=self.app_id), params={'filter[hostname]': query})
        if 'error' in data:
            raise APMException(data['error']['title'])
        return [i['id'] for i in data['application_instances']]

    # Here we gather metrics per instance and extract particular submetric timeseries of particular metric.
    # Returns [{id, data: [timeseries]}, ...]
    def get_metric_timeseries(self, metric_name, value_name, from_time, duration=3600):
        instance_ids = self.get_instance_ids_by_query(self.hostname_query)
        instance_timeseries = []
        start = from_time.replace(second=0, microsecond=0)
        end = (start - timedelta(seconds=duration)).replace(second=0, microsecond=0)
        for inst_id in instance_ids:
            data = newrelic_request(INSTANCE_METRICS_URL.format(app_id=self.app_id, instance_id=inst_id), params={
                'names[]': tuple(map(lambda m: m['nr_metric'], config['metrics'].values())),
                'from': end.isoformat(),
                'to': start.isoformat(),
            })
            values_timeseries = Metrics(data['metric_data']['metrics']).get_metric_values_timeseries(metric_name)
            try:
                instance_timeseries.append({"id": str(inst_id),
                                            "data": [[i, v] for i, v in enumerate(values_timeseries[value_name])]})
            except KeyError:
                raise KeyError('Value "{}" of metric "{}" could not be found.'.format(value_name, metric_name))
        return instance_timeseries


class NewRelicDriver(Measure):
    def ms(self):
        self.progress_message = 'Measurements started'
        self.print_progress()

    def me(self):
        self.progress = 100
        self.progress_message = 'Measurements completed'
        self.print_progress()

    timer = None
    time_to_wait = 0
    time_left = 0

    def stop_timer(self):
        if self.timer:
            self.timer.cancel()

    def start_timer(self):
        self.stop_timer()
        self.time_left -= 1
        self.timer = Timer(1, self.update_progress)
        self.timer.start()

    def update_progress(self):
        self.progress = int((1 - self.time_left / self.time_to_wait) * 100)
        self.start_timer()

    def measure(self):
        self.ms()

        control = self.input_data.get('control', {})
        warmup = int(control.get('warmup', DFLT_WARMUP))
        duration = int(control.get('duration', DFLT_DURATION))

        assert config['app_id'], 'You did not provide APM application id to query metrics from.'
        apm = APM(app_id=config['app_id'], instance_hostname_query=config['instance_hostname_query'])

        self.time_to_wait = warmup + duration
        self.time_left = self.time_to_wait
        self.start_timer()

        # warmup nap
        if warmup > 0:
            msg = 'WARMUP:  sleeping {} seconds'.format(warmup)
            self.progress_message = msg
            print(json.dumps({'progress': 0, 'message': msg}), flush=True)
            time.sleep(warmup)

        self.progress_message = 'Measuring'
        time.sleep(duration)
        metrics = {}
        start = datetime.now(timezone.utc)
        for name, metric in config['metrics'].items():
            metrics[name] = {
                "values": apm.get_metric_timeseries(metric_name=metric['nr_metric'], value_name=metric['nr_value'],
                                                    from_time=start, duration=duration)
            }

        self.me()
        return metrics, {}

    def describe(self):
        metrics = {}
        for k, v in config['metrics'].items():
            metrics[k] = dict((a, b) for a, b in v.items() if not a.startswith('nr_'))
        return metrics

    def handle_cancel(self, **kwargs):
        quit(0)


if __name__ == '__main__':
    driver = NewRelicDriver(cli_desc=DESC, supports_cancel=HAS_CANCEL, version=VERSION, progress_interval=1)
    driver.run()
