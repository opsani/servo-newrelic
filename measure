#!/usr/bin/env python3
import json
import time
from datetime import datetime, timedelta, timezone
from functools import reduce
from json import JSONDecodeError
from threading import Timer

import requests
import yaml

from measure import Measure

DESC = 'NewRelic measure driver for Optune'
HAS_CANCEL = True
VERSION = '0.0.1'

DFLT_WARMUP = 0
DFLT_DURATION = 120
DFLT_DELAY = 0

NEWRELIC_API_KEY = str(open('/run/secrets/optune_newrelic_api_key').read()).strip()
API_URL = 'https://api.newrelic.com/v2'
INSTANCE_METRICS_URL = '/applications/{app_id}/instances/{instance_id}/metrics/data.json'
INSTANCES_URL = '/applications/{app_id}/instances.json'

with open('./config.yaml') as f:
    config = yaml.load(f.read())['newrelic']

session = requests.Session()
session.headers.update({'X-Api-Key': NEWRELIC_API_KEY})


def newrelic_request(path, params, retries=5, method='get', **kwargs):
    retry = retries
    last_error = None
    while retry:
        try:
            res = getattr(session, method)(url=API_URL + path, params=params, **kwargs)
            return res.json()
        except Exception as e:
            last_error = e
            retry -= 1
            continue
        except JSONDecodeError as e:
            raise Exception('Expected JSON as a response from "{}" but got something else. '
                            'Error: {}'.format(path, str(e)))
    if last_error:
        raise last_error
    raise Exception('We ran out of retries (total {}) for NewRelic request to '
                    '"{} {}" with params "{}"'.format(retries, method.upper(), path, json.dumps(params)))


class Metrics:
    def __init__(self, metrics):
        self.metrics = {m['name']: m for m in metrics}

    def get_metric_values_timeseries(self, metric_name):
        # Convert from:
        # [{a: 1}, {a: 2}, {a: 3}]
        # To:
        # {a: [1, 2, 3]}
        def fn(memo, timeslice):
            ret = {**memo}
            for name, value in timeslice['values'].items():
                # Set empty array for the value we have not seen before.
                ret.setdefault(name, []).append(value)
            return ret
        assert metric_name in self.metrics, 'Requested metric with name "{}" is not found. ' \
                                            'Available metrics are ' \
                                            '"{}"'.format(metric_name, '", "'.join(self.metrics.keys()))
        # Convert from
        # [{values: {a: 1, b: 2, ...}}, ...]
        # To
        # {a: [1, 2, ...], ...}
        return reduce(fn, self.metrics[metric_name]['timeslices'], {})


class APMException(Exception):
    pass


class APM:
    def __init__(self, app_id):
        self.app_id = app_id

    def get_instance_ids_by_query(self, query):
        data = newrelic_request(INSTANCES_URL.format(app_id=self.app_id), params={'filter[hostname]': query})
        if 'error' in data:
            raise APMException(data['error']['title'])
        return [i['id'] for i in data['application_instances']]

    # Here we gather metrics per instance and extract particular submetric timeseries of particular metric.
    # Returns [{id, data: [timeseries]}, ...]
    def get_metric_timeseries(self, instance_ids, metric_name, value_name, from_time, to_time):
        instance_timeseries = []
        for inst_id in instance_ids:
            data = newrelic_request(INSTANCE_METRICS_URL.format(app_id=self.app_id, instance_id=inst_id), params={
                'names[]': tuple(map(lambda m: m['nr_metric'], config['metrics'].values())),
                'from': from_time.isoformat(),
                'to': to_time.isoformat(),
            })
            values_timeseries = Metrics(data['metric_data']['metrics']).get_metric_values_timeseries(metric_name)
            try:
                instance_timeseries.append({"id": str(inst_id),
                                            "data": [[i, v] for i, v in enumerate(values_timeseries[value_name])]})
            except KeyError:
                raise KeyError('Value "{}" of metric "{}" could not be found.'.format(value_name, metric_name))
        return instance_timeseries


class NewRelicDriver(Measure):
    timer = None
    time_to_wait = 0
    time_left = 0

    def stop_timer(self):
        if self.timer:
            self.timer.cancel()

    def start_timer(self):
        self.stop_timer()
        self.time_left -= 1
        self.timer = Timer(1, self.update_progress)
        self.timer.start()

    def update_progress(self):
        self.progress = int((1 - self.time_left / self.time_to_wait) * 80)
        self.start_timer()

    def measure(self):
        self.progress_message = 'Measurements started'
        self.print_progress()

        control = self.input_data.get('control', {})
        warmup = int(control.get('warmup', DFLT_WARMUP))
        duration = int(control.get('duration', DFLT_DURATION))
        delay = int(control.get('delay', DFLT_DELAY))

        assert config['app_id'], 'You did not provide APM application id to query metrics from.'
        apm = APM(app_id=config['app_id'])

        self.time_to_wait = warmup + duration + delay
        self.time_left = self.time_to_wait
        self.start_timer()

        # warmup nap
        if warmup > 0:
            msg = 'WARMUP: sleeping {} seconds'.format(warmup)
            self.progress_message = msg
            self.progress = 0
            time.sleep(warmup)

        # Wait for duration period before gathering measurements
        self.progress_message = 'DURATION: waiting {} seconds to gather measurements'.format(duration)
        time.sleep(duration)

        metrics = {}
        start = datetime.now(timezone.utc)

        # Delay measurements
        self.progress_message = 'DELAY: sleeping {} seconds'.format(delay)
        time.sleep(delay)
        self.stop_timer()

        self.progress_message = 'Gathering measurements'
        cmetrics = config['metrics']
        for i, (name, metric) in enumerate(cmetrics.items()):
            instance_ids = apm.get_instance_ids_by_query(metric.get('nr_hostname_query',
                                                                    config.get('nr_hostname_query')))
            self.progress = 80 + int(i / len(cmetrics) * 20)
            metrics[name] = {
                "values": apm.get_metric_timeseries(instance_ids=instance_ids,
                                                    metric_name=metric['nr_metric'], value_name=metric['nr_value'],
                                                    from_time=start - timedelta(seconds=duration),
                                                    to_time=start)
            }

        self.progress = 100
        self.progress_message = 'Measurements completed'
        self.print_progress()

        return metrics, {}

    def describe(self):
        metrics = {}
        for k, v in config['metrics'].items():
            metrics[k] = dict((a, b) for a, b in v.items() if not a.startswith('nr_'))
        return metrics

    def handle_cancel(self, **kwargs):
        print('Cancelling measurements')
        quit(0)


if __name__ == '__main__':
    driver = NewRelicDriver(cli_desc=DESC, supports_cancel=HAS_CANCEL, version=VERSION, progress_interval=1)
    driver.run()
